workspace:
  directory: /home/codio/workspace/codio-student-unit-exclude/ThinkJava2
  tex: thinkjava2.tex
  #removes inline code examples that are full programs (they auto-generate code files)
  removeTrinket: true
metadata:
  hideMenu: false
  protectLayout: false
  suppressPageNumbering: true
refs:
  #Offsets chapter numbering to match physical book
  chapter_counter_from: 0
assets:
 - code
 - fig: "*.jpg"
sections:
  - name: "Preface"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Philosophy Behind the Book"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Object-Oriented Programming"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Changes to the Second Edition"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "About the Appendixes"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Using the Code Examples"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Acknowledgments"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Computer Programming"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is a Computer?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is Programming?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Hello World Program"
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |
                 See the example java code in the left pane. To compile and run the code, press the "Run!"
                 {Run!}(sh .guides/bg.sh javac code/ch01/Hello.java java -cp code/ch01/ Hello )

          position: 105
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch01/Hello.java"
            panel: 0
            action: open
  - name: "Compiling Java Programs"
    type: section
  - name: "Displaying Two Messages"
    type: section
  - name: "Formatting Source Code"
    type: section
  - name: "Using Escape Sequences"
    type: section
  - name: "What Is Computer Science?"
    type: section
  - name: "Debugging Programs"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Variables and Operators"
    type: chapter
  - name: "Declaring Variables"
    type: section
  - name: "Assigning Variables"
    type: section
  - name: "Memory Diagrams"
    type: section
  - name: "Printing Variables"
    type: section
  - name: "Arithmetic Operators"
    type: section
  - name: "Floating-Point Numbers"
    type: section
  - name: "Rounding Errors"
    type: section
  - name: "Operators for Strings"
    type: section
  - name: "Compiler Error Messages"
    type: section
  - name: "Other Types of Errors"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Input and Output"
    type: chapter
  - name: "The System Class"
    type: section
  - name: "The Scanner Class"
    type: section
  - name: "Language Elements"
    type: section
  - name: "Literals and Constants"
    type: section
  - name: "Formatting Output"
    type: section
  - name: "Reading Error Messages"
    type: section
  - name: "Type Cast Operators"
    type: section
  - name: "Remainder Operator"
    type: section
  - name: "Putting It All Together"
    type: section
  - name: "The Scanner Bug"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Methods and Testing"
    type: chapter
  - name: "Defining New Methods"
    type: section
  - name: "Flow of Execution"
    type: section
  - name: "Parameters and Arguments"
    type: section
  - name: "Multiple Parameters"
    type: section
  - name: "Stack Diagrams"
    type: section
  - name: "Math Methods"
    type: section
  - name: "Composition"
    type: section
  - name: "Return Values"
    type: section
  - name: "Incremental Development"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Conditionals and Logic"
    type: chapter
  - name: "Relational Operators"
    type: section
  - name: "The if-else Statement"
    type: section
  - name: "Chaining and Nesting"
    type: section
  - name: "The switch Statement"
    type: section
  - name: "Logical Operators"
    type: section
  - name: "De Morgan's Laws"
    type: section
  - name: "Boolean Variables"
    type: section
  - name: "Boolean Methods"
    type: section
  - name: "Validating Input"
    type: section
  - name: "Example Program"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Loops and Strings"
    type: chapter
  - name: "The while Statement"
    type: section
  - name: "Increment and Decrement"
    type: section
  - name: "The for Statement"
    type: section
  - name: "Nested Loops"
    type: section
  - name: "Characters"
    type: section
  - name: "Which Loop to Use"
    type: section
  - name: "String Iteration"
    type: section
  - name: "The indexOf Method"
    type: section
  - name: "Substrings"
    type: section
  - name: "String Comparison"
    type: section
  - name: "String Formatting"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays and References"
    type: chapter
  - name: "Creating Arrays"
    type: section
  - name: "Accessing Elements"
    type: section
  - name: "Displaying Arrays"
    type: section
  - name: "Copying Arrays"
    type: section
  - name: "Traversing Arrays"
    type: section
  - name: "Random Numbers"
    type: section
  - name: "Building a Histogram"
    type: section
  - name: "The Enhanced for Loop"
    type: section
  - name: "Counting Characters"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Recursive Methods"
    type: chapter
  - name: "Recursive Void Methods"
    type: section
  - name: "Recursive Stack Diagrams"
    type: section
  - name: "Value-Returning Methods"
    type: section
  - name: "The Leap of Faith"
    type: section
  - name: "Counting Up Recursively"
    type: section
  - name: "Binary Number System"
    type: section
  - name: "Recursive Binary Method"
    type: section
  - name: "CodingBat Problems"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Immutable Objects"
    type: chapter
  - name: "Primitives vs Objects"
    type: section
  - name: "The null Keyword"
    type: section
  - name: "Strings Are Immutable"
    type: section
  - name: "Wrapper Classes"
    type: section
  - name: "Command-Line Arguments"
    type: section
  - name: "Argument Validation"
    type: section
  - name: "BigInteger Arithmetic"
    type: section
  - name: "Incremental Design"
    type: section
  - name: "More Generalization"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Mutable Objects"
    type: chapter
  - name: "Point Objects"
    type: section
  - name: "Objects as Parameters"
    type: section
  - name: "Objects as Return Values"
    type: section
  - name: "Rectangles Are Mutable"
    type: section
  - name: "Aliasing Revisited"
    type: section
  - name: "Java Library Source"
    type: section
  - name: "Class Diagrams"
    type: section
  - name: "Scope Revisited"
    type: section
  - name: "Garbage Collection"
    type: section
  - name: "Mutable vs Immutable"
    type: section
  - name: "StringBuilder Objects"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Designing Classes"
    type: chapter
  - name: "The Time Class"
    type: section
  - name: "Constructors"
    type: section
  - name: "Value Constructors"
    type: section
  - name: "Getters and Setters"
    type: section
  - name: "Displaying Objects"
    type: section
  - name: "The toString Method"
    type: section
  - name: "The equals Method"
    type: section
  - name: "Adding Times"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Objects"
    type: chapter
  - name: "Card Objects"
    type: section
  - name: "Card toString"
    type: section
  - name: "Class Variables"
    type: section
  - name: "The compareTo Method"
    type: section
  - name: "Cards Are Immutable"
    type: section
  - name: "Arrays of Cards"
    type: section
  - name: "Sequential Search"
    type: section
  - name: "Binary Search"
    type: section
  - name: "Tracing the Code"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Objects of Arrays"
    type: chapter
  - name: "Decks of Cards"
    type: section
  - name: "Shuffling Decks"
    type: section
  - name: "Selection Sort"
    type: section
  - name: "Merge Sort"
    type: section
  - name: "Subdecks"
    type: section
  - name: "Merging Decks"
    type: section
  - name: "Adding Recursion"
    type: section
  - name: "Static Context"
    type: section
  - name: "Piles of Cards"
    type: section
  - name: "Playing War"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Extending Classes"
    type: chapter
  - name: "CardCollection"
    type: section
  - name: "Inheritance"
    type: section
  - name: "Dealing Cards"
    type: section
  - name: "The Player Class"
    type: section
  - name: "The Eights Class"
    type: section
  - name: "Class Relationships"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Arrays"
    type: chapter
  - name: "Conway's Game of Life"
    type: section
  - name: "The Cell Class"
    type: section
  - name: "Two-Dimensional Arrays"
    type: section
  - name: "The GridCanvas Class"
    type: section
  - name: "Other Grid Methods"
    type: section
  - name: "Starting the Game"
    type: section
  - name: "The Simulation Loop"
    type: section
  - name: "Exception Handling"
    type: section
  - name: "Counting Neighbors"
    type: section
  - name: "Updating the Grid"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Reusing Classes"
    type: chapter
    transformations:
        - remove: 1
          position: 16
        - add:  |
            You can read more about it at [this site](open_preview https://en.wikipedia.org/wiki/Langtons_ant panel=0)
          position: 17  
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Langton's Ant"
    type: section
    transformations:
        - remove: 1
          position: 26
        - add:  |
            We begin by defining a `Langton` class that has a grid and information about the ant, as seen [at the left.](open_file code/ch16/Langton.java panel=0 ref="public class Langton" count=19)
            [Click to remove highlight](open_file code/ch16/Langton.java panel=0)
          position: 27
        - remove: 1
          position: 51
        - add:  |
            Here's an `update` method that implements the rules for Langton's Ant, also seen [at the left.](open_file code/ch16/Langton.java panel=0 ref="void update" count=4)
            [Click to remove highlight](open_file code/ch16/Langton.java panel=0)
          position: 52
        - remove: 1
          position: 60
        - add:  |
            The `flipCell` method gets the `Cell` at the ant's location, figures out which way to turn, and changes the state of the cell, as seen [at the left.](open_file code/ch16/Langton.java panel=0 ref="flipCell" count=11)
            [Click to remove highlight](open_file code/ch16/Langton.java panel=0)
          position: 61
        - remove: 1
          position: 81
        - add:  |
            The `moveAnt` method moves the ant forward one square, using `head` to determine which way is forward, as shown below and [at the left.](open_file code/ch16/Langton.java panel=0 ref="moveAnt" count=10)
            [Click to remove highlight](open_file code/ch16/Langton.java panel=0)
          position: 82  
        - remove: 1
          position: 97
        - add:  |
            Here is the `main` method we use to create and display the `Langton` object, also shown [at the left.](open_file code/ch16/Langton.java panel=0 ref="public static void main" count=10)
            [Click to remove highlight](open_file code/ch16/Langton.java panel=0)
            
            {Run!}(javac code/ch16/Langton.java && java -cp code/ch16/ Langton) 
          position: 98  
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch16/Langton.java"
            panel: 0
            action: open
  - name: "Refactoring"
    type: section
    transformations:
        - remove: 1
          position: 130
        - add:  |
            First, we define a superclass named `Automaton`, in which we will put the code that `Conway` and `Langton` have in common, as seen at the left.
          position: 131
        - remove: 1
          position: 148
        - add:  |
            
            `Automaton` declares `grid` as an instance variable, as seen [at the left](open_file code/misc/Automaton.java panel=0 ref="GridCanvas grid" count=1), so every `Automaton` "has~a" `GridCanvas`. 
            [Click to remove highlight](open_file code/misc/Automaton.java panel=0)
          position: 149
        - remove: 1
          position: 152
        - add:  |
            It uses `title` when creating the `JFrame`, and it passes `rate` to `mainloop`, which is shown [at the left](open_file code/misc/Automaton.java panel=0 ref="void mainloop" count=14).
            [Click to remove highlight](open_file code/misc/Automaton.java panel=0)
          position: 153
        - remove: 1
          position: 173
        - add:  |
            It runs a `while` loop forever (or until the window closes), as shown [here](open_file code/misc/Automaton.java panel=0 ref="while" count=1).
            [Click to remove highlight](open_file code/misc/Automaton.java panel=0)
          position: 174
        - remove: 1
          position: 174
        - add:  |
            Each time through the loop, it [runs](open_file code/misc/Automaton.java panel=0 ref="this.update" count=1) `update` to update `grid` and then [runs](open_file code/misc/Automaton.java panel=0 ref="repaint" count=1) `repaint` to redraw the grid.
            [Click to remove highlight](open_file code/misc/Automaton.java panel=0)
          position: 175
        - remove: 1
          position: 176
        - add:  |
            Then it [calls](open_file code/misc/Automaton.java panel=0 ref="Thread.sleep" count=1) `Thread.sleep` with a delay that depends on `rate`.
            [Click to remove highlight](open_file code/misc/Automaton.java panel=0)
            
            {Run!}(javac code/misc/Langton.java && java -cp code/misc/ Automaton) 
          position: 177
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/misc/Automaton.java"
            panel: 0
            action: open
  - name: "Abstract Classes"
    type: section
    transformations:
        - remove: 10
          position: 209
        - add:  |
              * We can make the `grid` attribute `protected` (shown [here](open_file code/ch16/Automaton.java panel=0 ref="protected" count=1)), which means it's accessible to subclasses but not other classes.
              * We can make the class `abstract` (shown [here](open_file code/ch16/Automaton.java panel=0 ref="abstract" count=1)), which means it cannot be instantiated. If you attempt to create an object for an abstract class, you will get a compiler error.
              * We can declare `update` as an `abstract` method (shown [here](open_file code/ch16/Automaton.java panel=0 ref="abstract void update" count=1)), meaning that it must be overridden in subclasses. If the subclass does not override an abstract method, you will get a compiler error.
              [Click to remove highlights](open_file code/ch16/Automaton.java panel=0)
          position: 219
        - remove: 1
          position: 248
        - add:  |
             Here's what `Conway` looks like as a subclass of `Automaton`, shown below and [to the left](open_file code/ch16/Conway.java panel=0)
             
             {Run!}(javac code/ch16/Conway.java && java -cp code/ch16/ Conway) 
          position: 249 
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch16/Automaton.java"
            panel: 0
            action: open
  - name: "UML Diagram"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Vocabulary"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Exercises"
    type: section
    transformations:
        - remove: 23
          position: 328
        - add:  |
              The following exercises will give you a chance to check your knowledge before moving on.
          position: 327
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Exercise 16.1"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch16/Automaton.java"
            panel: 0
            action: open
          - path: "code/ch16/Langton.java"
            panel: 0 
            action: open
  - name: "Exercise 16.2"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch16/Automaton.java"
            panel: 0
            action: open
          - path: "code/ch16/Cell.java"
            panel: 0
            action: open
          - path: "code/ch16/GridCanvas.java"
            panel: 0
            action: open
          - path: "code/ch16/YourAutomaton.java"
            panel: 0
            action: open
  - name: "Advanced Topics"
    type: chapter
  - name: "Polygon Objects"
    type: section
  - name: "Adding Color"
    type: section
  - name: "Regular Polygons"
    type: section
  - name: "More Constructors"
    type: section
  - name: "An Initial Drawing"
    type: section
  - name: "Blinking Polygons"
    type: section
  - name: "Interfaces"
    type: section
  - name: "Event Listeners"
    type: section
  - name: "Timers"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Tools"
    type: chapter
  - name: "Installing DrJava"
    type: section
  - name: "DrJava Interactions"
    type: section
  - name: "Command-Line Interface"
    type: section
  - name: "Command-Line Testing"
    type: section
  - name: "Running Checkstyle"
    type: section
  - name: "Tracing with a Debugger"
    type: section
  - name: "Testing with JUnit"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Javadoc"
    type: chapter
  - name: "Reading Documentation"
    type: section
  - name: "Writing Documentation"
    type: section
  - name: "Javadoc Tags"
    type: section
  - name: "Example Source File"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Graphics"
    type: chapter
  - name: "Creating Graphics"
    type: section
  - name: "Graphics Methods"
    type: section
  - name: "Example Drawing"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Debugging"
    type: chapter
  - name: "Compile-Time Errors"
    type: section
  - name: "Run-Time Errors"
    type: section
  - name: "Logic Errors"
    type: section
insert_sections:
  - name: Exercise 16.1
    type: section
    chapter: Reusing classes
    section: Exercises
    before: false
    markdown: |
      **Exercise 16.1:**
      The last section of this chapter introduced `Automaton` as an abstract class and rewrote `Conway` as a subclass of `Automaton`. Now it's your turn: rewrite `Langton` as a subclass of `Automaton`, removing the code that's no longer needed.

  - name: Exercise 16.2
    type: section
    chapter: Reusing classes
    section: Exercises
    before: false
    markdown: |
      
      **Exercise 16.2:**
      Mathematically speaking, Game of Life and Langton's Ant are *cellular automata*. “Cellular” means it has cells, and “automaton” means it runs itself. See [https://en.wikipedia.org/wiki/Cellular_automaton](https://en.wikipedia.org/wiki/Cellular_automaton) for more discussion.

      Implement another cellular automaton of your choice. You may have to modify `Cell` and/or `GridCanvas`, in addition to extending `Automaton`. For example, Brian's Brain ([https://en.wikipedia.org/wiki/Brian's_Brain](https://en.wikipedia.org/wiki/Brian's_Brain)) requires three states: “on”, “dying”, and “off”.