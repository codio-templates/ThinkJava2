workspace:
  directory: /home/codio/workspace/codio-student-unit-exclude/ThinkJava2
  tex: thinkjava2.tex
  #removes inline code examples that are full programs (they auto-generate code files)
  removeTrinket: true
metadata:
  hideMenu: false
  protectLayout: false
  suppressPageNumbering: true
refs:
  #Offsets chapter numbering to match physical book
  chapter_counter_from: 0
assets:
 - code
 - fig: "*.jpg"
sections:
  - name: "Preface"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Philosophy Behind the Book"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Object-Oriented Programming"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Changes to the Second Edition"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "About the Appendixes"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Using the Code Examples"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Acknowledgments"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Computer Programming"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is a Computer?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is Programming?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Hello World Program"
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |
                 See the example java code in the left pane. To compile and run the code, press the "Run!"
                 {Run!}(sh .guides/bg.sh javac code/ch01/Hello.java java -cp code/ch01/ Hello )

          position: 105
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch01/Hello.java"
            panel: 0
            action: open
  - name: "Compiling Java Programs"
    type: section
  - name: "Displaying Two Messages"
    type: section
  - name: "Formatting Source Code"
    type: section
  - name: "Using Escape Sequences"
    type: section
  - name: "What Is Computer Science?"
    type: section
  - name: "Debugging Programs"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Variables and Operators"
    type: chapter
  - name: "Declaring Variables"
    type: section
  - name: "Assigning Variables"
    type: section
  - name: "Memory Diagrams"
    type: section
  - name: "Printing Variables"
    type: section
  - name: "Arithmetic Operators"
    type: section
  - name: "Floating-Point Numbers"
    type: section
  - name: "Rounding Errors"
    type: section
  - name: "Operators for Strings"
    type: section
  - name: "Compiler Error Messages"
    type: section
  - name: "Other Types of Errors"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Input and Output"
    type: chapter
  - name: "The System Class"
    type: section
  - name: "The Scanner Class"
    type: section
  - name: "Language Elements"
    type: section
  - name: "Literals and Constants"
    type: section
  - name: "Formatting Output"
    type: section
  - name: "Reading Error Messages"
    type: section
  - name: "Type Cast Operators"
    type: section
  - name: "Remainder Operator"
    type: section
  - name: "Putting It All Together"
    type: section
  - name: "The Scanner Bug"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Methods and Testing"
    type: chapter
  - name: "Defining New Methods"
    type: section
  - name: "Flow of Execution"
    type: section
  - name: "Parameters and Arguments"
    type: section
  - name: "Multiple Parameters"
    type: section
  - name: "Stack Diagrams"
    type: section
  - name: "Math Methods"
    type: section
  - name: "Composition"
    type: section
  - name: "Return Values"
    type: section
  - name: "Incremental Development"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Conditionals and Logic"
    type: chapter
  - name: "Relational Operators"
    type: section
  - name: "The if-else Statement"
    type: section
  - name: "Chaining and Nesting"
    type: section
  - name: "The switch Statement"
    type: section
  - name: "Logical Operators"
    type: section
  - name: "De Morgan's Laws"
    type: section
  - name: "Boolean Variables"
    type: section
  - name: "Boolean Methods"
    type: section
  - name: "Validating Input"
    type: section
  - name: "Example Program"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Loops and Strings"
    type: chapter
  - name: "The while Statement"
    type: section
  - name: "Increment and Decrement"
    type: section
  - name: "The for Statement"
    type: section
  - name: "Nested Loops"
    type: section
  - name: "Characters"
    type: section
  - name: "Which Loop to Use"
    type: section
  - name: "String Iteration"
    type: section
  - name: "The indexOf Method"
    type: section
  - name: "Substrings"
    type: section
  - name: "String Comparison"
    type: section
  - name: "String Formatting"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays and References"
    type: chapter
  - name: "Creating Arrays"
    type: section
  - name: "Accessing Elements"
    type: section
  - name: "Displaying Arrays"
    type: section
  - name: "Copying Arrays"
    type: section
  - name: "Traversing Arrays"
    type: section
  - name: "Random Numbers"
    type: section
  - name: "Building a Histogram"
    type: section
  - name: "The Enhanced for Loop"
    type: section
  - name: "Counting Characters"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Recursive Methods"
    type: chapter
  - name: "Recursive Void Methods"
    type: section
  - name: "Recursive Stack Diagrams"
    type: section
  - name: "Value-Returning Methods"
    type: section
  - name: "The Leap of Faith"
    type: section
  - name: "Counting Up Recursively"
    type: section
  - name: "Binary Number System"
    type: section
  - name: "Recursive Binary Method"
    type: section
  - name: "CodingBat Problems"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Immutable Objects"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Primitives vs Objects"
    type: section
    transformations:
        - remove: 6
          position: 30
        - add:  |
                 Figure 1 shows how the computer stores the results of [this assignment code to the left](open_file code/ch09/Objects.java panel=0 ref="int" count=2) in memory. 
                 
                 ```
                  int number = -2;
                  char symbol = '!';
                 ```
                 
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 36
        - remove: 5
          position: 50
        - add:  |
                 For example, [this code to the left](open_file code/ch09/Objects.java panel=0 ref="char[]" count=1) declares a variable named `array` and creates an array of three characters.
                 
                 ```
                 char[] array = {'c', 'a', 't'};
                 ```
                 
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 55
        - remove: 5
          position: 67
        - add:  |
                For example, [this line](open_file code/ch09/Objects.java panel=0 ref="String word" count=1) declares a `String` variable named `word` and creates a `String` object, as shown in the below figure.
                
                ```
                String word = "dog";
                ```
                
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 72
        - remove: 6
          position: 82
        - add:  |
                For convenience, you don't have to use `new` to create strings:, as shown [on the left.](open_file code/ch09/Objects.java panel=0 ref="String word1" count=2)
                
                ```
                String word1 = new String("dog");  // creates a string object
                String word2 = "dog";  // implicitly creates a string object
                ```
                
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 88
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Objects.java"
            panel: 0
            action: open
  - name: "The null Keyword"
    type: section
    transformations:
        - remove: 6
          position: 107
        - add:  |
                 You can initialize object and array variables using `null` as shown [on the left.](open_file code/ch09/Objects.java panel=0 ref="null" count=4)
                 
                 ```
                  String name0 = null;
                  int[] combo = null;
                 ```
                 
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 113
        - remove: 6
          position: 127
        - add:  |
                 If you try to use a variable that is `null` by invoking a method or accessing an element, Java throws a `NullPointerException`, as in the two cases [on the left.](open_file code/ch09/Objects.java panel=0 ref="NullPointerException" count=2)
                 
                 ```
                  System.out.println(name0.length());  // NullPointerException
                  System.out.println(combo[0]);        // NullPointerException
                 ```
                 
                 To see what a NullPointerException looks like, try removing the comments from the two lines of code and clicking "Run!" below.
                 {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 1)
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 133
  - name: "Strings Are Immutable"
    type: section
    transformations:
        - remove: 6
          position: 153
        - add:  |
                 For example, consider [this code on the left.](open_file code/ch09/Objects.java panel=0 ref="immutable" count=4)
                 
                 ```
                  String name = "Alan Turing";
                  String upperName = name.toUpperCase();
                 ```
                 
                 You'll need to remove the comments from these lines of code in order to run the next steps. (You'll also need to re-comment out the NullPointerException lines.)
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 159
        - remove: 8
          position: 164
        - add:  |
                 A common mistake is to assume that `toUpperCase` somehow affects the original string, as in [this code on the left.](open_file code/ch09/Objects.java panel=0 ref="ignores" count=2)
                 
                 ```
                  name.toUpperCase();           // ignores the return value
                  System.out.println(name);
                 ```
                 
                 Remove the comments from this code and press "Run!" to see what happens. 
                 {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 2)
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 172
        - remove: 7
          position: 173
        - add:  |
                 If you want to change `name` to be uppercase, then you need to assign the return value: as in [this code on the left.](open_file code/ch09/Objects.java panel=0 ref="references" count=2)
                 
                 ```
                  name = name.toUpperCase();    // references the new string
                  System.out.println(name);
                 ```
                 
                 Remove the comments from this code and press "Run!" to see what happens. 
                 {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 3)
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 180
        - remove: 6
          position: 184
        - add:  |
                 [This example](open_file code/ch09/Objects.java panel=0 ref="Computer Science" count=2) replaces `"Computer Science"` with `"CS"`.
                 
                 ```
                  String text = "Computer Science is fun!";
                  text = text.replace("Computer Science", "CS");
                 ```
                 
                 Remove the comments from this code and press "Run!" to see what happens. 
                 {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 4)
                 [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 190
  - name: "Wrapper Classes"
    type: section
    transformations:
        - remove: 6
          position: 219
        - add:  |
                The wrapper class for `int` is named `Integer`, with a capital `I`. The above example works when you change the data type to `Integer`, as seen [on the left.](open_file code/ch09/Objects.java panel=0 ref="Integer" count=2)
                
                ```
                  Integer i = Integer.valueOf(5);
                  System.out.println(i.equals(5));  // displays true
                ```
                
                Remove the comments from this code and press "Run!" to see what happens. 
                {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 5)
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 225
        - remove: 12
          position: 229
        - add:  |
                Like strings, objects from wrapper classes are immutable, and you have to use the `equals` method to compare them, as in the example [on the left.](open_file code/ch09/Objects.java panel=0 ref="Integer x" count=8)
                
                ```
                  Integer x = Integer.valueOf(123);
                  Integer y = Integer.valueOf(123);
                  if (x == y) {                     // false
                      System.out.println("x and y are the same object");
                  }
                  if (x.equals(y)) {                // true
                      System.out.println("x and y have the same value");
                  }
                ```
                
                Remove the comments from this code and press "Run!" to see what happens. 
                {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 6)
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                **Note**: for some reason this is printing out the first statement even though the first condition should be false.
                 
          position: 241
        - remove: 5
          position: 254
        - add:  |
                For an example usage of `parseInt()`, look at the example [on the left.](open_file code/ch09/Objects.java panel=0 ref="String str" count=2)
                
                ```
                String str = "12345";
                int num = Integer.parseInt(str);
                ```
                
                Remove the comments from this code and press "Run!" to see what happens. 
                {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 7)
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 259
        - remove: 6
          position: 260
        - add:  |
                They also provide `toString`, which returns a string representation of a value, as seen [on the left.](open_file code/ch09/Objects.java panel=0 ref="toString" count=3)
                
                ```
                  num = 12345;
                  str = Integer.toString(num);
                ```
                
                Remove the comments from this code and press "Run!" to see what happens. 
                {Run!}(sh .guides/bg.sh javac code/ch09/Objects.java java -cp code/ch09/ Objects 8)
                [Click to remove highlight](open_file code/ch09/Objects.java panel=0)
                 
          position: 266
  - name: "Command-Line Arguments"
    type: section
    transformations:
        - remove: 10
          position: 292
        - add:  |
                For a starting point, consider the program on the upper left, noting that any command line instructions will be typed into the terminal on the lower left. 
                 
          position: 302
        - remove: 1
          position: 324
        - add:  |
                 The first line of output, representing the initial array of arguments, is shown here: 
          position: 325
        - remove: 12
          position: 334
        - add:  |
                The code [on the left](open_file code/ch09/Max.java panel=0 ref="int max" count=7) uses an enhanced `for` loop (see Section 7.8) to parse the arguments and find the largest value.
                ```
                int max = Integer.MIN_VALUE;
                for (String arg : args) {
                    int value = Integer.parseInt(arg);
                    if (value > max) {
                        max = value;
                    }
                }
                System.out.println("The max is " + max);
                ```
          position: 346
        - remove: 8
          position: 352
        - add:  |
                We can prevent this situation from happening by checking `args` at the beginning of the program, as seen [on the left.](open_file code/ch09/Max.java panel=0 ref="length" count=4)
 
          position: 360
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Max.java"
            panel: 0
            action: open
          - path: "#terminal: cd code/ch09"
            panel: 1
            action: open
  - name: "Argument Validation"
    type: section
    transformations:
        - remove: 7
          position: 388
        - add:  |
                We can write this method using the `Character` wrapper class, as [in the original version of the method at the left.](open_file code/ch09/ArgValid.java panel=0 ref="Old" count=4)
                [Click to remove highlight](open_file code/ch09/ArgValid.java panel=0)
                 
          position: 395
        - remove: 10
          position: 414
        - add:  |
                If it's invalid, we return before executing the rest of the method, [as shown in the new version of the method at the left.](open_file code/ch09/ArgValid.java panel=0 ref="New" count=7)
                [Click to remove highlight](open_file code/ch09/ArgValid.java panel=0)
                Press "Run!" to see what happens on the four test cases in the `main` method. 
                {Run!}(sh .guides/bg.sh javac code/ch09/ArgValid.java java -cp code/ch09/ ArgValid 1)
                
          position: 424
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/ArgValid.java"
            panel: 0
            action: open
  - name: "BigInteger Arithmetic"
    type: section
    transformations:
        - remove: 6
          position: 472
        - add:  |
               The [code on the left](open_file code/ch09/BigInt.java panel=0 ref="long" count=3) converts a `long` to a `BigInteger`.
               Press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/BigInt.java java -cp code/ch09/ BigInt 1)
               [Click to remove highlight](open_file code/ch09/BigInt.java panel=0)
                 
          position: 478
        - remove: 6
          position: 480
        - add:  |
               The [code on the left](open_file code/ch09/BigInt.java panel=0 ref="String s" count=3) shows how this feature can help us handle a 20-digit integer that is too big to store using a `long`.
               Remove the comment symbols and press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/BigInt.java java -cp code/ch09/ BigInt 2)
               [Click to remove highlight](open_file code/ch09/BigInt.java panel=0)
                 
          position: 486
        - remove: 7
          position: 491
        - add:  |
               To add two BigIntegers, we invoke `add` on one and pass the other as an argument, as in the [code on the left.](open_file code/ch09/BigInt.java panel=0 ref="BigInteger a" count=4)
               Remove the comment symbols and press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/BigInt.java java -cp code/ch09/ BigInt 3)
               [Click to remove highlight](open_file code/ch09/BigInt.java panel=0)
                 
          position: 498
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/BigInt.java"
            panel: 0
            action: open
  - name: "Incremental Design"
    type: section
    transformations:
        - remove: 9
          position: 541
        - add:  |
               The starter code at the left is a loop that displays the multiples of two, all on one line. Press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 7)
               
          position: 550
        - remove: 11
          position: 568
        - add:  |
                 The next step is to **encapsulate** the code; that is, we "wrap" the code in a method. Create a new method `public static void printRow()`, move the code in `main` into it, and call the method from `main`. Press "Run!" to see what happens. 
                 {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 8)

                 Here's what the code should look like when you're done. 
                   ```
                   public class Tables {
                    public static void main(String[] args) {
                      printRow();
                    }

                    public static void printRow() {
                      for (int i = 1; i <= 6; i++) {
                        System.out.printf("%4d", 2 * i);
                      }
                      System.out.println();
                    }

                  }
                  ```
                
          position: 579
        - add:  |
               Try generalizing the method, then press "Run!" to see what happens. (You'll have to pass an argument into the call in `main`.) {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 1)
               Here's what the code should look like when you're done.
          position: 584
        - add:  |
               Try copying that loop into the main method, and press "Run!" to see what happens. {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 2)
               Here's what the code should look like when you're done.
          position: 629
          
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Tables.java"
            panel: 0
            action: open
  - name: "More Generalization"
    type: section
    transformations:
        - remove: 1
          position: 634
        - add:  |
               We can encapsulate the outer loop in a method too. Try creating `public static void printTable()` with the code currently in the main method as the body of the function. Call the method from `main`. 
               Press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 3)
               Here's what the code should look like when you're done: 
               
          position: 635
        - remove: 1
          position: 645
        - add:  |
               We can generalize it by replacing the literal `6` with a parameter, int `rows`. See if you can print different times tables by changing the argument in the method call. 
               Press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 4)
               Here's what the method should look like when you're done:
               
          position: 646
        - remove: 1
          position: 692
        - add:  |
               As a result, the number of columns equals the number of rows, so we get a square 7 x 7 table, instead of the previous 7 x 6 table.
               Once you've made both of the above changes, press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 5)
              
          position: 693
        - add:  |
               Press "Run!" to see what happens. 
               {Run!}(sh .guides/bg.sh javac code/ch09/Tables.java java -cp code/ch09/ Tables 6)
              
          position: 726
          
  - name: "Vocabulary"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Exercises"
    type: section
    transformations:
        - remove: 208
          position: 781
        - add:  |
               The following exercises will give you a chance to check your knowledge of immutable objects before moving on.
              
          position: 989
  - name: "Exercise 9.1"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Test.java"
            panel: 0
            action: open
  - name: "Exercise 9.2"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Big.java"
            panel: 0
            action: open
  - name: "Exercise 9.3"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Pow.java"
            panel: 0
            action: open
  - name: "Exercise 9.4"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/MoreExponents.java"
            panel: 0
            action: open
  - name: "Exercise 9.5"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/MoreExponents.java" # temp waiting for chapter 7 files
            panel: 0
            action: open
  - name: "Exercise 9.6"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch09/Parens.java"
            panel: 0
            action: open
  - name: "Mutable Objects"
    type: chapter
  - name: "Point Objects"
    type: section
  - name: "Objects as Parameters"
    type: section
  - name: "Objects as Return Values"
    type: section
  - name: "Rectangles Are Mutable"
    type: section
  - name: "Aliasing Revisited"
    type: section
  - name: "Java Library Source"
    type: section
  - name: "Class Diagrams"
    type: section
  - name: "Scope Revisited"
    type: section
  - name: "Garbage Collection"
    type: section
  - name: "Mutable vs Immutable"
    type: section
  - name: "StringBuilder Objects"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Designing Classes"
    type: chapter
  - name: "The Time Class"
    type: section
  - name: "Constructors"
    type: section
  - name: "Value Constructors"
    type: section
  - name: "Getters and Setters"
    type: section
  - name: "Displaying Objects"
    type: section
  - name: "The toString Method"
    type: section
  - name: "The equals Method"
    type: section
  - name: "Adding Times"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Objects"
    type: chapter
  - name: "Card Objects"
    type: section
  - name: "Card toString"
    type: section
  - name: "Class Variables"
    type: section
  - name: "The compareTo Method"
    type: section
  - name: "Cards Are Immutable"
    type: section
  - name: "Arrays of Cards"
    type: section
  - name: "Sequential Search"
    type: section
  - name: "Binary Search"
    type: section
  - name: "Tracing the Code"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Objects of Arrays"
    type: chapter
  - name: "Decks of Cards"
    type: section
  - name: "Shuffling Decks"
    type: section
  - name: "Selection Sort"
    type: section
  - name: "Merge Sort"
    type: section
  - name: "Subdecks"
    type: section
  - name: "Merging Decks"
    type: section
  - name: "Adding Recursion"
    type: section
  - name: "Static Context"
    type: section
  - name: "Piles of Cards"
    type: section
  - name: "Playing War"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Extending Classes"
    type: chapter
  - name: "CardCollection"
    type: section
  - name: "Inheritance"
    type: section
  - name: "Dealing Cards"
    type: section
  - name: "The Player Class"
    type: section
  - name: "The Eights Class"
    type: section
  - name: "Class Relationships"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Arrays"
    type: chapter
  - name: "Conway's Game of Life"
    type: section
  - name: "The Cell Class"
    type: section
  - name: "Two-Dimensional Arrays"
    type: section
  - name: "The GridCanvas Class"
    type: section
  - name: "Other Grid Methods"
    type: section
  - name: "Starting the Game"
    type: section
  - name: "The Simulation Loop"
    type: section
  - name: "Exception Handling"
    type: section
  - name: "Counting Neighbors"
    type: section
  - name: "Updating the Grid"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Reusing Classes"
    type: chapter
  - name: "Langton's Ant"
    type: section
  - name: "Refactoring"
    type: section
  - name: "Abstract Classes"
    type: section
  - name: "UML Diagram"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Advanced Topics"
    type: chapter
  - name: "Polygon Objects"
    type: section
  - name: "Adding Color"
    type: section
  - name: "Regular Polygons"
    type: section
  - name: "More Constructors"
    type: section
  - name: "An Initial Drawing"
    type: section
  - name: "Blinking Polygons"
    type: section
  - name: "Interfaces"
    type: section
  - name: "Event Listeners"
    type: section
  - name: "Timers"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Tools"
    type: chapter
  - name: "Installing DrJava"
    type: section
  - name: "DrJava Interactions"
    type: section
  - name: "Command-Line Interface"
    type: section
  - name: "Command-Line Testing"
    type: section
  - name: "Running Checkstyle"
    type: section
  - name: "Tracing with a Debugger"
    type: section
  - name: "Testing with JUnit"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Javadoc"
    type: chapter
  - name: "Reading Documentation"
    type: section
  - name: "Writing Documentation"
    type: section
  - name: "Javadoc Tags"
    type: section
  - name: "Example Source File"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Graphics"
    type: chapter
  - name: "Creating Graphics"
    type: section
  - name: "Graphics Methods"
    type: section
  - name: "Example Drawing"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Debugging"
    type: chapter
  - name: "Compile-Time Errors"
    type: section
  - name: "Run-Time Errors"
    type: section
  - name: "Logic Errors"
    type: section
insert_sections:
  - name: Exercise 9.1
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      The point of this exercise is to explore Java types and fill in some of the details that aren't covered in the chapter.

      \index{concatenate}

      \begin{enumerate}

      \item In the program to the left, \java{Test.java}, write a \java{main} method that contains expressions that combine various types using the \java{+} operator.
      For example, what happens when you ``add'' a \java{String} and a \java{char}?
      Does it perform character addition or string concatenation?
      What is the type of the result?
      %(How can you determine the type of the result?)
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/Test.java java -cp code/ch09/ Test 1)

      \item  Make a bigger copy of the following table and fill it in. At the intersection of each pair of types, you should indicate whether it is legal to use the `+` operator with these types by indicating `Yes` or `No` in the table. (For the `String` type, exclude empty-string concatenation for now. This is a special case that you should try in #5.) Also, consider for each case - is this addition or concatenation? What is the data type of the result?
      {Check It!|assessment}(fill-in-the-blanks-2087744111)

      \item Think about some of the choices the designers of Java made, based on this table.
      How many of the entries seem unavoidable, as if there was no other choice?
      How many seem like arbitrary choices from several equally reasonable possibilities?
      Which entries seem most problematic?

      \item Here's a puzzler: normally, the statement \java{x++} is exactly equivalent to \java{x = x + 1}.
      But if \java{x} is a \java{char}, it's not exactly the same!
      In that case, \java{x++} is legal, but \java{x = x + 1} causes an error.
      Try it out.
      See what the error message is, and then see if you can figure out what is going on.
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/Test.java java -cp code/ch09/ Test 2)


      \item What happens when you add \java{""} (the empty string) to the other types; for example, \java{"" + 5}?

      %\item For each data type, what types of values can you assign to it?
      %For example, you can assign an \java{int} to a \java{double} but not vice versa.

      \end{enumerate}

  - name: Exercise 9.2
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      \index{factorial}

      You might be sick of the \java{factorial} method by now, but we're going to do one more version.

      \begin{enumerate}

      \item Create a new program called {\it Big.java} and write an iterative version of \java{factorial} (using a \java{for} loop).

      \item Display a table of the integers from 0 to 30 along with their factorials.
      At some point around 15, you will probably see that the answers are not correct anymore.
      Why not?

      \item Convert \java{factorial} so that it performs its calculation using BigIntegers and returns a \java{BigInteger} as a result.
      You can leave the parameter alone; it will still be an integer.

      \item Try displaying the table again with your modified factorial method.
      Is it correct up to 30?
      How high can you make it go?
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/Big.java java -cp code/ch09/ Big 1)

      \end{enumerate}

  - name: Exercise 9.3
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      Many encryption algorithms depend on the ability to raise large integers to a power.
      The class on the left contains a method `pow(int x, int n)` that implements an efficient algorithm for integer exponentiation.
      
      The problem with this method is that it works only if the result is small enough to be represented by an \java{int}.
      Rewrite it so that the result is a \java{BigInteger}.
      The parameters should still be integers, though.

      You should use the \java{BigInteger} methods \java{add} and \java{multiply}.
      But don't use \java{BigInteger.pow}; that would spoil the fun.
      
      Add a main method and some function calls, then test your code using the class below.
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/Pow.java java -cp code/ch09/ Pow 1)


  - name: Exercise 9.4
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      %The purpose of this exercise is to practice using \java{BigInteger} and \java{BigDecimal}.

      One way to calculate $e^x$ is to use the following infinite series expansion.
      The $i$th term in the series is $x^i / i!$.
      %
      \[ e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + \ldots \]
      %
      \begin{enumerate}

      \item Write a method called \java{myexp} that takes \java{x} and \java{n} as parameters and estimates $e^x$ by adding the first \java{n} terms of this series.
      You can use the \java{factorial} method from Section~\ref{factorial} or your iterative version from the previous exercise.

      {Test your code}(sh .guides/bg.sh javac code/ch09/MoreExponents.java java -cp code/ch09/ MoreExponents 1)
      
      \index{efficiency}

      \item You can make this method more efficient by observing that the numerator of each term is the same as its predecessor multiplied by \java{x}, and the denominator is the same as its predecessor multiplied by \java{i}.

      Use this observation to eliminate the use of \java{Math.pow} and \java{factorial}, and check that you get the same result.

      \item Write a method called \java{check} that takes a parameter, \java{x}, and displays \java{x}, \java{myexp(x)}, and \java{Math.exp(x)}.
      The output should look like this:

      \begin{stdout}
      1.0     2.708333333333333     2.718281828459045
      \end{stdout}

      Use the escape sequence \java{'\\t'} to display a tab character between each of the values.

      \item Vary the number of terms in the series (the second argument that \java{check} sends to \java{myexp}) and see the effect on the accuracy of the result.
      Adjust this value until the estimated value agrees with the correct answer when \java{x} is 1.
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/MoreExponents.java java -cp code/ch09/ MoreExponents 2)
      
      \item Write a loop in \java{main} that invokes \java{check} with the values 0.1, 1.0, 10.0, and 100.0.
      How does the accuracy of the result vary as \java{x} varies?
      Compare the number of digits of agreement rather than the difference between the actual and estimated values.

      \item Add a loop in \java{main} that checks \java{myexp} with the values -0.1, -1.0, -10.0, and -100.0.
      Comment on the accuracy.
      
      \end{enumerate}
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/MoreExponents.java java -cp code/ch09/ MoreExponents 3)
      
  - name: Exercise 9.5
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      The goal of this exercise is to practice encapsulation and generalization using some of the examples in previous chapters.

      \begin{enumerate}

      \item Starting with the code in Section~\ref{traversal}, write a method called \java{powArray} that takes a \java{double} array, \java{a}, and returns a new array that contains the elements of \java{a} squared.
      Generalize it to take a second argument and raise the elements of \java{a} to the given power.

      \item Starting with the code in Section~\ref{enhanced}, write a method called \java{histogram} that takes an \java{int} array of scores from 0 to (but not including) 100, and returns a histogram of 100 counters.
      Generalize it to take the number of counters as an argument.

      \end{enumerate}
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/MoreExponents.java java -cp code/ch09/ MoreExponents 1)
      

  - name: Exercise 9.6
    type: section
    chapter: Immutable Objects
    section: Exercises
    before: false
    latex: |

      \index{encapsulation}
      \index{generalization}

      %The purpose of this exercise is to review encapsulation and generalization (see Section~\ref{encapsulation}).
      The code to the left traverses a string and checks whether it has the same number of opening and closing parentheses. However, it is currently in the main method.

      \begin{enumerate}

      \item Move the code out of the main method. Instead, encapsulate it in a method that takes a string argument and returns the final value of \java{count}.

      \item Test your method with multiple strings, including some that are balanced and some that are not.

      \item Generalize the code so that it works on any string. What could you do to generalize it more?

      \end{enumerate}
      
      {Test your code}(sh .guides/bg.sh javac code/ch09/Parens.java java -cp code/ch09/ Parens 1)
      

