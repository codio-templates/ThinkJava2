workspace:
  directory: /home/codio/workspace/codio-student-unit-exclude/ThinkJava2
  tex: thinkjava2.tex
  #removes inline code examples that are full programs (they auto-generate code files)
  removeTrinket: true
metadata:
  hideMenu: false
  protectLayout: false
  suppressPageNumbering: true
refs:
  #Offsets chapter numbering to match physical book
  chapter_counter_from: 0
assets:
 - code
 - fig: "*.jpg"
sections:
  - name: "Preface"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Philosophy Behind the Book"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Object-Oriented Programming"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Changes to the Second Edition"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "About the Appendixes"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Using the Code Examples"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Acknowledgments"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Computer Programming"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is a Computer?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "What Is Programming?"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "The Hello World Program"
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |
                 See the example java code in the left pane. To compile and run the code, press the "Run!"
                 {Run!}(sh .guides/bg.sh javac code/ch01/Hello.java java -cp code/ch01/ Hello )

          position: 105
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch01/Hello.java"
            panel: 0
            action: open
  - name: "Compiling Java Programs"
    type: section
  - name: "Displaying Two Messages"
    type: section
  - name: "Formatting Source Code"
    type: section
  - name: "Using Escape Sequences"
    type: section
  - name: "What Is Computer Science?"
    type: section
  - name: "Debugging Programs"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Variables and Operators"
    type: chapter
  - name: "Declaring Variables"
    type: section
  - name: "Assigning Variables"
    type: section
  - name: "Memory Diagrams"
    type: section
  - name: "Printing Variables"
    type: section
  - name: "Arithmetic Operators"
    type: section
  - name: "Floating-Point Numbers"
    type: section
  - name: "Rounding Errors"
    type: section
  - name: "Operators for Strings"
    type: section
  - name: "Compiler Error Messages"
    type: section
  - name: "Other Types of Errors"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Input and Output"
    type: chapter
  - name: "The System Class"
    type: section
  - name: "The Scanner Class"
    type: section
  - name: "Language Elements"
    type: section
  - name: "Literals and Constants"
    type: section
  - name: "Formatting Output"
    type: section
  - name: "Reading Error Messages"
    type: section
  - name: "Type Cast Operators"
    type: section
  - name: "Remainder Operator"
    type: section
  - name: "Putting It All Together"
    type: section
  - name: "The Scanner Bug"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Methods and Testing"
    type: chapter
  - name: "Defining New Methods"
    type: section
  - name: "Flow of Execution"
    type: section
  - name: "Parameters and Arguments"
    type: section
  - name: "Multiple Parameters"
    type: section
  - name: "Stack Diagrams"
    type: section
  - name: "Math Methods"
    type: section
  - name: "Composition"
    type: section
  - name: "Return Values"
    type: section
  - name: "Incremental Development"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Conditionals and Logic"
    type: chapter
  - name: "Relational Operators"
    type: section
  - name: "The if-else Statement"
    type: section
  - name: "Chaining and Nesting"
    type: section
  - name: "The switch Statement"
    type: section
  - name: "Logical Operators"
    type: section
  - name: "De Morgan's Laws"
    type: section
  - name: "Boolean Variables"
    type: section
  - name: "Boolean Methods"
    type: section
  - name: "Validating Input"
    type: section
  - name: "Example Program"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Loops and Strings"
    type: chapter
  - name: "The while Statement"
    type: section
  - name: "Increment and Decrement"
    type: section
  - name: "The for Statement"
    type: section
  - name: "Nested Loops"
    type: section
  - name: "Characters"
    type: section
  - name: "Which Loop to Use"
    type: section
  - name: "String Iteration"
    type: section
  - name: "The indexOf Method"
    type: section
  - name: "Substrings"
    type: section
  - name: "String Comparison"
    type: section
  - name: "String Formatting"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays and References"
    type: chapter
  - name: "Creating Arrays"
    type: section
  - name: "Accessing Elements"
    type: section
  - name: "Displaying Arrays"
    type: section
  - name: "Copying Arrays"
    type: section
  - name: "Traversing Arrays"
    type: section
  - name: "Random Numbers"
    type: section
  - name: "Building a Histogram"
    type: section
  - name: "The Enhanced for Loop"
    type: section
  - name: "Counting Characters"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Recursive Methods"
    type: chapter
  - name: "Recursive Void Methods"
    type: section
  - name: "Recursive Stack Diagrams"
    type: section
  - name: "Value-Returning Methods"
    type: section
  - name: "The Leap of Faith"
    type: section
  - name: "Counting Up Recursively"
    type: section
  - name: "Binary Number System"
    type: section
  - name: "Recursive Binary Method"
    type: section
  - name: "CodingBat Problems"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Immutable Objects"
    type: chapter
  - name: "Primitives vs Objects"
    type: section
  - name: "The null Keyword"
    type: section
  - name: "Strings Are Immutable"
    type: section
  - name: "Wrapper Classes"
    type: section
  - name: "Command-Line Arguments"
    type: section
  - name: "Argument Validation"
    type: section
  - name: "BigInteger Arithmetic"
    type: section
  - name: "Incremental Design"
    type: section
  - name: "More Generalization"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Mutable Objects"
    type: chapter
  - name: "Point Objects"
    type: section
  - name: "Objects as Parameters"
    type: section
  - name: "Objects as Return Values"
    type: section
  - name: "Rectangles Are Mutable"
    type: section
  - name: "Aliasing Revisited"
    type: section
  - name: "Java Library Source"
    type: section
  - name: "Class Diagrams"
    type: section
  - name: "Scope Revisited"
    type: section
  - name: "Garbage Collection"
    type: section
  - name: "Mutable vs Immutable"
    type: section
  - name: "StringBuilder Objects"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Designing Classes"
    type: chapter
  - name: "The Time Class"
    type: section
  - name: "Constructors"
    type: section
  - name: "Value Constructors"
    type: section
  - name: "Getters and Setters"
    type: section
  - name: "Displaying Objects"
    type: section
  - name: "The toString Method"
    type: section
  - name: "The equals Method"
    type: section
  - name: "Adding Times"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Objects"
    type: chapter
  - name: "Card Objects"
    type: section
  - name: "Card toString"
    type: section
  - name: "Class Variables"
    type: section
  - name: "The compareTo Method"
    type: section
  - name: "Cards Are Immutable"
    type: section
  - name: "Arrays of Cards"
    type: section
  - name: "Sequential Search"
    type: section
  - name: "Binary Search"
    type: section
  - name: "Tracing the Code"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Objects of Arrays"
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Decks of Cards"
    type: section
    transformations:
        - remove: 15
          position: 24
        - add:  |
                 At the left is the beginning of a `Deck` class that encapsulates an array of `Card` objects. We still need to fill in most of its methods.
          position: 39
        - remove: 1
          position: 44
        - remove: 15
          position: 55
        - add:  |
                 [This constructor](open_file code/ch13/Deck.java panel=0 ref="int n" count=3) initializes the instance variable with an array of `n` cards, but it doesn't create any `Card` objects. Figure 13.1 shows what a `Deck` looks like with no cards.
                 
                 ```
                  public Deck(int n) {
                      this.cards = new Card[n];
                  }
                 ```
                 
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)


                 Instead, we can use [our other constructor](open_file code/ch13/Deck.java panel=0 ref="public Deck" count=10) to create a standard 52-card array and populate it with `Card` objects.
                 
                 ```
                  public Deck() {
                      this.cards = new Card[52];
                      int index = 0;
                      for (int suit = 0; suit <= 3; suit++) {
                          for (int rank = 1; rank <= 13; rank++) {
                              this.cards[index] = new Card(rank, suit);
                              index++;
                          }
                      }
                  }
                 ```
                 
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)

          position: 70
        - remove: 9
          position: 81
        - add:  |
                 [Here's how it looks](open_file code/ch13/Deck.java panel=0 ref="print" count=5), rewritten as an instance method of `Deck`.
                 
                 ```
                  public void print() {
                      for (Card card : this.cards) {
                          System.out.println(card);
                      }
                  }
                 ```
                 
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 90
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch13/Deck.java"
            panel: 0
            action: open
  - name: "Shuffling Decks"
    type: section
    transformations:
        - remove: 1
          position: 120
        - add:  |
                 For more on this, see [https://en.wikipedia.org/wiki/Faro_shuffle](open_preview https://en.wikipedia.org/wiki/Faro_shuffle panel=0).
          position: 121
        - remove: 1
          position: 126
        - add:  |
                 This technique is sometimes called **pseudocode**, and it is also found as a series of comments within the stub method [at the left.](open_file code/ch13/Deck.java panel=0 ref="shuffle" count=6)
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 127
        - remove: 1
          position: 143
        - add:  |
                 In this case, we need a method that chooses a random integer in a given range and a method that takes two indexes and swaps the cards at those positions. These stub methods are in the code file [on the left.](open_file code/ch13/Deck.java panel=0 ref="int low" count=10)
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 144
        - remove: 1
          position: 165
        - add:  |
                 The process of writing pseudocode first and then writing helper methods to make it work is a kind of **top-down design** (see [https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design](open_preview https://en.wikipedia.org/wiki/Top-down_and_bottom-up_design panel=0)).
          position: 166
  - name: "Selection Sort"
    type: section
    transformations:
        - remove: 1
          position: 186
        - add:  |
                 Pseudocode for selection sort can be found [at the left.](open_file code/ch13/Deck.java panel=0 ref="selectionSort" count=6)
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 187
        - add:  |
                 The stub method can be seen [at the left.](open_file code/ch13/Deck.java panel=0 ref="indexLowest" count=3)
                 [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 199
  - name: "Merge Sort"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Subdecks"
    type: section
    transformations:
        - remove: 1
          position: 256
        - add:  |
                So we need a method that takes a deck, and a range of indexes, and returns a new deck that contains the specified subset of cards. 
                This method can be seen [at the left.](open_file code/ch13/Deck.java panel=0 ref="subdeck" count=7)
                [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 257
        - remove: 1
          position: 268
        - add:  |
                [The first line](open_file code/ch13/Deck.java panel=0 ref="new Deck" count=1) creates an unpopulated `Deck` object that contains an array of `null` references.
                [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 269
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/ch13/Deck.java"
            panel: 0
            action: open
  - name: "Merging Decks"
    type: section
    transformations:
        - remove: 1
          position: 315
        - add:  |
                Here's what the algorithm looks like in pseudocode, assuming the subdecks are named `d1` and `d2`:
                This method can also seen [at the left.](open_file code/ch13/Deck.java panel=0 ref="merge" count=19)
                [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 316
        - remove: 1
          position: 341
        - add:  |
                Once your `merge` method is working, you can use it to write a simplified version of merge sort, as shown below and [at the left.](open_file code/ch13/Deck.java panel=0 ref="almostMergeSort" count=6)
                [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 342
  - name: "Adding Recursion"
    type: section
    transformations:
        - remove: 1
          position: 366
        - add:  |
                With these base cases, a recursive version of `mergeSort` looks like the method [at the left.](open_file code/ch13/Deck.java panel=0 ref="Deck mergeSort" count=8)
                [Click to remove highlight](open_file code/ch13/Deck.java panel=0)
          position: 367
  - name: "Static Context"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Piles of Cards"
    type: section
    transformations:
        - remove: 1
          position: 494
        - add:  |
                One of the simplest card games that children play is called “War” (see [https://en.wikipedia.org/wiki/War_(card_game)](open_preview https://en.wikipedia.org/wiki/War_(card_game) panel=0)).
          position: 495
        - remove: 1
          position: 518
        - add:  |
                It uses an `ArrayList` to store `Card` objects, as seen [on the left](open_file code/ch13/Pile.java panel=0 ref="Pile" count=11). 
                [Click to remove highlight](open_file code/ch13/Pile.java panel=0)
          position: 519
        - remove: 1
          position: 543
        - add:  |
                So we define a method to do that, as shown [on the left](open_file code/ch13/Pile.java panel=0 ref="popCard" count=3). 
                [Click to remove highlight](open_file code/ch13/Pile.java panel=0)
          position: 544
        - remove: 1
          position: 558
        - add:  |
                So we define a method to do that, as seen [on the left](open_file code/ch13/Pile.java panel=0 ref="addCard" count=3). 
                [Click to remove highlight](open_file code/ch13/Pile.java panel=0)
          position: 559
        - remove: 1
          position: 569
        - add:  |
                Here's a method to do that, also provided [on the left](open_file code/ch13/Pile.java panel=0 ref="isEmpty" count=3). 
                [Click to remove highlight](open_file code/ch13/Pile.java panel=0)
          position: 570
        - remove: 1
          position: 581
        - add:  |
                We can do that with `subdeck` from before as well as a new method, `addDeck`, as shown [on the left](open_file code/ch13/Pile.java panel=0 ref="addDeck" count=5).
                [Click to remove highlight](open_file code/ch13/Pile.java panel=0)
          position: 582 
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/Pile.java"
            panel: 0
            action: open
  - name: "Playing War"
    type: section
    transformations:
        - remove: 1
          position: 599
        - add:  |
                We'll start by creating a deck and shuffling, as shown [on the left.](open_file code/ch13/War.java panel=0 ref="create" count=3)
                [Click to remove highlight](open_file code/ch13/War.java panel=0)
          position: 600
        - remove: 1
          position: 606
        - add:  |
                Then we divide the `Deck` into two piles, as seen [on the left.](open_file code/ch13/War.java panel=0 ref="divide" count=5)
                [Click to remove highlight](open_file code/ch13/War.java panel=0)
          position: 607  
        - remove: 1
          position: 617
        - add:  |
                At each iteration, we draw a card from each pile and compare their ranks, as shown [on the left.](open_file code/ch13/War.java panel=0 ref="while" count=17)
                [Click to remove highlight](open_file code/ch13/War.java panel=0)
          position: 618
        - remove: 1
          position: 645
        - add:  |
                After the `while` loop ends, we display the winner based on which pile is not empty, as shown [on the left.](open_file code/ch13/War.java panel=0 ref="display" count=6)
                [Click to remove highlight](open_file code/ch13/War.java panel=0)
          position: 646
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/War.java"
            panel: 0
            action: open
  - name: "Vocabulary"
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: "Exercises"
    type: section
    transformations:
        - remove: 117
          position: 698
        - add:  |
                Now that you understand how these algorithms work, you can finish implementing the classes in this chapter. The following exercises are based off of the stub methods explained throughout the chapter. 
          position: 697
  - name: "Exercise 13.1"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/Deck.java"
            panel: 0
            action: open
  - name: "Exercise 13.2"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/Deck.java"
            panel: 0
            action: open
  - name: "Exercise 13.3"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/Deck.java"
            panel: 0
            action: open
  - name: "Exercise 13.4"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/InsertionSort.java"
            panel: 0
            action: open
  - name: "Exercise 13.5"
    type: section
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "/code/ch13/War.java"
            panel: 0
            action: open
  - name: "Extending Classes"
    type: chapter
  - name: "CardCollection"
    type: section
  - name: "Inheritance"
    type: section
  - name: "Dealing Cards"
    type: section
  - name: "The Player Class"
    type: section
  - name: "The Eights Class"
    type: section
  - name: "Class Relationships"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Arrays of Arrays"
    type: chapter
  - name: "Conway's Game of Life"
    type: section
  - name: "The Cell Class"
    type: section
  - name: "Two-Dimensional Arrays"
    type: section
  - name: "The GridCanvas Class"
    type: section
  - name: "Other Grid Methods"
    type: section
  - name: "Starting the Game"
    type: section
  - name: "The Simulation Loop"
    type: section
  - name: "Exception Handling"
    type: section
  - name: "Counting Neighbors"
    type: section
  - name: "Updating the Grid"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Reusing Classes"
    type: chapter
  - name: "Langton's Ant"
    type: section
  - name: "Refactoring"
    type: section
  - name: "Abstract Classes"
    type: section
  - name: "UML Diagram"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Advanced Topics"
    type: chapter
  - name: "Polygon Objects"
    type: section
  - name: "Adding Color"
    type: section
  - name: "Regular Polygons"
    type: section
  - name: "More Constructors"
    type: section
  - name: "An Initial Drawing"
    type: section
  - name: "Blinking Polygons"
    type: section
  - name: "Interfaces"
    type: section
  - name: "Event Listeners"
    type: section
  - name: "Timers"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Tools"
    type: chapter
  - name: "Installing DrJava"
    type: section
  - name: "DrJava Interactions"
    type: section
  - name: "Command-Line Interface"
    type: section
  - name: "Command-Line Testing"
    type: section
  - name: "Running Checkstyle"
    type: section
  - name: "Tracing with a Debugger"
    type: section
  - name: "Testing with JUnit"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Javadoc"
    type: chapter
  - name: "Reading Documentation"
    type: section
  - name: "Writing Documentation"
    type: section
  - name: "Javadoc Tags"
    type: section
  - name: "Example Source File"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Graphics"
    type: chapter
  - name: "Creating Graphics"
    type: section
  - name: "Graphics Methods"
    type: section
  - name: "Example Drawing"
    type: section
  - name: "Vocabulary"
    type: section
  - name: "Exercises"
    type: section
  - name: "Debugging"
    type: chapter
  - name: "Compile-Time Errors"
    type: section
  - name: "Run-Time Errors"
    type: section
  - name: "Logic Errors"
    type: section
insert_sections:
  - name: Exercise 13.1
    type: section
    chapter: Objects of Arrays
    section: Exercises
    before: false
    markdown: |
      Write a `toString` method for the `Deck` class. It should return a single string that represents the cards in the deck. When it's printed, this string should display the same results as the `print` method in Section 13.1.
      *Hint:* You can use the `+` operator to concatenate strings, but that is not very efficient. Consider using `StringBuilder` instead; see Section 10.11.
      
      [Click to view tester class](open_file code/ch13/Test.java panel=0)
      [Click to return to Deck class](open_file code/ch13/Deck.java panel=0)
      
      {Run!}(sh .guides/bg2.sh javac code/ch13/Test.java code/ch13/Deck.java code/ch13/Card.java java -cp code/ch13/ Test 0)
      
  - name: Exercise 13.2
    type: section
    chapter: Objects of Arrays
    section: Exercises
    before: false
    markdown: |
      The goal of this exercise is to implement the shuffling algorithm from this chapter.

      1. In the repository for this book, you should find the file named *Deck.java*. Check that you can compile it in your environment.
      1. Implement the `randomInt` method. You can use the `nextInt` method provided by `java.util.Random`, which you saw in Section 7.6. *Hint:* To avoid creating a `Random` object every time `randomInt` is invoked, consider defining a class variable.
      1. Write a `swapCards` method that takes two indexes and swaps the cards at the given locations.
      1. Fill in the `shuffle` method by using the algorithm in Section 13.2.
      
      [Click to view tester class](open_file code/ch13/Test.java panel=0)
      [Click to return to Deck class](open_file code/ch13/Deck.java panel=0)

      {Run!}(sh .guides/bg2.sh javac code/ch13/Test.java code/ch13/Deck.java code/ch13/Card.java java -cp code/ch13/ Test 1)

  - name: Exercise 13.3
    type: section
    chapter: Objects of Arrays
    section: Exercises
    before: false
    markdown: |
      The goal of this exercise is to implement the sorting algorithms from this chapter. Use the *Deck.java* file from the previous exercise or create a new one from scratch.

      1. Implement the `indexLowest` method. Use the `Card.compareTo` method to find the lowest card in a given range of the deck, from `lowIndex` to `highIndex`, including both.
      1. Fill in `selectionSort` by using the algorithm in Section 13.3.
      1. Using the pseudocode in Section 13.4, implement the `merge` method. The best way to test it is to build and shuffle a deck. Then use `subdeck` to form two small subdecks, and use selection sort to sort them. Finally, pass the two halves to `merge` and see if it works.
      1. Fill in `almostMergeSort`, which divides the deck in half, then uses `selectionSort` to sort the two halves, and uses `merge` to create a new, sorted deck. You should be able to reuse code from the previous step.
      1. Implement `mergeSort` recursively. Remember that `selectionSort` is `void` and `mergeSort` returns a new `Deck`, which means that they get invoked differently: 
      ```code
      deck.selectionSort();      // modifies an existing deck
      deck = deck.mergeSort();   // replaces old deck with new
      ```
      [Click to view tester class](open_file code/ch13/Test.java panel=0)
      [Click to return to Deck class](open_file code/ch13/Deck.java panel=0)
      
      {Run!}(sh .guides/bg2.sh javac code/ch13/Test.java code/ch13/Deck.java code/ch13/Card.java java -cp code/ch13/ Test 2)
       
  - name: Exercise 13.4
    type: section
    chapter: Objects of Arrays
    section: Exercises
    before: false
    markdown: |
      You can learn more about the sorting algorithms presented in this chapter at [https://www.toptal.com/developers/sorting-algorithms](https://www.toptal.com/developers/sorting-algorithms). This site provides explanations of the algorithms, along with animations that show how they work. It also includes an analysis of their efficiency.

      For example, “insertion sort” is an algorithm that inserts elements into place, one at a time. Read about it on the website and play the animations. Then write a method named `insertionSort` that implements this algorithm.

      One goal of this exercise is to practice top-down design. Your solution should use a helper method, named `insert`, that implements the inner loop of the algorithm. `insertionSort` should invoke this method $n-1$ times.

       {Run!}(sh .guides/bg.sh javac code/ch13/InsertionSort.java java -cp code/ch13/ InsertionSort )
    
  - name: Exercise 13.5
    type: section
    chapter: Objects of Arrays
    section: Exercises
    before: false
    markdown: |
      Find and open the file *War.java* in the repository. The `main` method contains all the code from the last section of this chapter. Check that you can compile and run this code before proceeding.

      The program is incomplete; it does not handle the case when two cards have the same rank. Finish implementing the `main` method, beginning at the line that says: `// it's a tie`.

      When there's a tie, draw three cards from each pile and store them in a collection, along with the original two. Then draw one more card from each pile and compare them. Whoever wins the tie takes all ten of these cards.

      If one pile does not have at least four cards, the game ends immediately. If a tie ends with a tie, draw three more cards, and so on.

      Notice that this program depends on `Deck.shuffle`, so you might have to do Exercise 13.2 first.
      
      {Run!}(sh .guides/bg3.sh javac code/ch13/War.java code/ch13/Pile.java code/ch13/Deck.java code/ch13/Card.java java -cp code/ch13/ War 0)